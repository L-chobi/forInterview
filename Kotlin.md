## Kotlin
- 100% 자바와 호환이 가능하며 간결한 문법과 높은 안전성으로 높은 생산성을 보장한다고 함.
- 자바 프로젝트에 코틀린 코드를 추가 가능하고, 자바 코드를 코틀린으로 변환할 수도 있음.

### 간결한 문법?
- 자바에서 코드 맨 뒤에 붙이던 세미콜론(;)을 붙일 필요가 없게됨
- 객체 생성시 자바는 new 키워드가 필요했지만 코틀린은 그럴 필요가 없어짐
- 보통 자바나 c는 타입을 명시하며 변수나 상수를 선언했지만 코틀린에서는 타입 추론을 지원하여 일반적인 경우 타입을 명시할 필요가 없어짐(var, val 사용).
- 일반적인 경우란 초기화시 값을 할당하는 경우를 말함(컴파일러가 변수 타입을 추론할 수 있는 경우).

#### var, val?
##### val(value)
- val로 지정된 불변 타입 변수는 나중에 값을 변경할 수 없음. 즉, 초기화만 가능하고 변경이 불가(자바의 final과 비슷).
- 값의 읽기만 허용된다고 볼 수 있음.
- 그러나 변수의 참조가 가리키는 객체의 내부 값은 변경이 가능(자바스크립트의 const와 유사)

##### var(variable)
- var로 지정된 가변 타입 변수는 초기화 후 값을 변경 가능. 그러나 다른 타입의 값을 넣을 수는 없음.
- 값의 읽기와 쓰기가 모두 허용된다고 볼 수 있음.

##### 둘의 차이
- 한마디로 값을 다시 할당할 수 있는지임. val은 불가능하지만 var는 가능(재할당하려는 값이 기존의 것과 같은 타입인 경우만)

### 널(null) 안전성
- 자바에서는 객체 타입의 변수에서 null 값 허용 여부에 대해 구분할 수 없었으나 코틀린은 ?, !! 을 이용하여 구분할 수 있음.
- 널값의 허용 여부를 컴파일 단계에서 검사하기 때문에 런타임 에러를 줄일 수 있음.

### 람다 표현식 지원
- 람다 함수란 익명 함수를 지칭하는 용어.
- 코틀린에서 보통 함수의 정의는 fun 예약어를 이용함(람다 함수는 함수명도, fun 예약어도 사용 안함). 
- 보통의 함수는 function name(parameter) {function body} 식으로 정의하지만 
- 코틀린의 경우 val func = {parameter: type -> body} 식으로 정의할 수 있음.
- -> 왼쪽이 매개변수 영역(매개변수 이름, 타입), 오른쪽이 함수 내용.
- 람다 함수에서는 함수 내용의 마지막 줄이 반환값이므로 return 문을 명시하지 않아도 됨.

### 스트림 API 지원
- 자바8에서는 컬렉션에 포함된 자료들을 손쉽게 다룰 수 있도록 스트림(stream) 기능을 제공함.
- 코틀린에서는 이와 유사한 역할을 하는 함수들을 표준 라이브러리에서 제공하며, 확장 함수 형태로 제공함.
- map, mapIndexed, filter, take, drop, first 등이 있음.
- 변환, 필터, 조합 및 합계 등이 있음.

### 자바와의 완벽한 호환성
- 코틀린, 자바 모두 자바 기반 환경에서 그대로 사용 가능하므로 자바 라이브러리 모두 호환이 가능

## 코틀린 문법
### 타입 지정
- 자바가 변수를 선언하며 int a = 0 처럼 사용한다면 코틀린은 val이나 var를 타입을 지정하여 사용함.
- var a: Int = 0 이런 식임.
- var a = 0 이런 식으로도 가능. 이는 코틀린이 리터럴(여기서는 0)에 따라 자료형을 추론하기 떄문임

### 리터럴?
- 리터럴이란 자료형을 알 수 있는 표기 형식임. 
- var a = 0에서는 0, var b = "test"에서는 ""을 통해 string 자료형임을 추론함.

### 문자열 탬플릿
- 자바에서 문자열을 잇는데 + 등을 사용했다면 코틀린은 ""안에 ${parameter}을 넣어 출력이 가능함(자바스크립트에서 백틱 사용과 비슷).
- 변수만이 아니라 if 문 등의 식도 넣을 수 있음.

### 디폴트 파라미터
- 함수에서 인수를 받을 때 디폴트로 값을 지정 가능(타입스크립트와 같음)
- 자바는 불가능하나 Build Pattern을 쓰면 비슷하게는 가능하다고 함.
- fun funName(x: Int = 0, y: String = ''): returnType {} 식으로 사용.

### 리스트(불변, 가변)
- 코틀린은 리스트가 두 가지임. 불변형(immutable) 리스트와 가변형(mutable) 리스트.
- 불변형은 listOf()로, 가변형은 mutableListOf()로 사용.
- 가변형은 add, removeAt 등 변형이 가능하지만 불변형은 읽기만 가능.

### 불변, 가변 맵
- 리스트처럼 불변형 맵과 가변형 맵이 있음.
- 가변은 mutableMapOf, 불변은 mapOf

### 문(statement), 식(expression)
- 식은 값을 만들어냄(간단하게 값을 return).
- 자바에서 if 문 등에 return 값을 사용한다면 식의 경우 return을 명시하지 않아도 됨. 
- return a 대신 a 라고만 적거나, 자바의 switch에서 각 경우마다 return을 쓰는 대신 코틀린에서는 -> 로 간단하게 표현.

### lazy, lateinit
#### lateinit
- 예시로 lateinit var a: Int 라고 하면, 처음에 var 형태의 a가 Int 타입이며, 나중에 사용된다는 것을 의미함.
- 그 후 a에 값을 주면 a에 값이 들어감.
- var a:Int? = null과 다른 점은 타입이 Int?가 아닌 Int라는 점임.
- 그렇기에 x는 null이 아닌 초기화되지 않은 상태로 존재함(초기화 전까지 사용하면 안됨). 

#### lazy(by lazy)
- lazy를 사용할 시 var는 사용할 수 없음(val만 가능)회
- val 선언 뒤 by lazy 블록에서 초기화에 필요한 코드를 작성. 호출시점에서 최초 1회 초기화가 됨.
- lateinit과 다르게 선언과 동시에 초기화를 해야함.
- 모양만 보면 변수 선언과 동시에 초기화를 선언하지만 호출시점에서 초기화가 이루어지므로 늦은 초기화임.

#### 둘의 차이
- lateinit은 var로만, lazy는 val로만 선언됨.
- 초기화 이후 값이 변할 수 있는 경우 lateinit, 반대라면 by lazy를 쓰는 것이 좋음.

### 고차함수
- 함수를 인수로 받거나 결과로 반환할 수 있는 함수를 말함.
- 고차함수에 매개변수로 주어지는 식을 람다 표현식이라고도 부름.
