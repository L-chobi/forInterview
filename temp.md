## DTO를 따로 두는 이유?
### DTO란?
- DTO란 Data Transfer Object의 약자로 계층 간 데이터 교환 역할을 한다. 
- DTO는 데이터 조작을 위한 것이 아닌 순수하게 계층간 데이터 교환이 이루어질 수 있도록 하는 객체이기 때문에 특별한 로직을 가지고 있으면 안된다. 

### DTO를 이해해 보자
- DTO를 이해하기 전, DTO가 필요한 이유를 먼저 알면 이해가 더 쉽지 않을까 싶다.
- DTO란 개념은 왜 나왔을까? 우리는 프로그램의 불안전성에 크게 한 몫하는게 네트워크 통신임을 알고 있다. 코드의 오작동을 떠나서 네트워크 통신의 오류로 인해 주고받는 데이터에 결함이 생긴다거나, 아예 신호가 안갔다거나 하는 등의 오류는 나처럼 네트워크는 잘 모르는 초보 개발자에겐 큰 절망이 될 수 있다. 서론이 길었지만 어쨌거나 네트워크는 예상치 못한 에러가 될 수 있다. 오죽하면 체크섬 같은 패킷 헤더 등으로 데이터의 무결성을 체크할까.
- 그렇기에 외부와 통신하는 프로그램에 있어 호출은 큰 비용이자 잠재적 오류가 될 수 있다. 그렇다면 이를 줄이고 더욱 효과적으로 데이터를 주고받을 필요가 있다. 
- 이를 위해 데이터를 모아 한 번에 전달하는 방법이 고안되었다. 이때 이 클래스를 DTO라고 한다.

### DTO가 필요한 이유
- 앞서 우리는 DTO가 필요한 이유를 알아보았다. 정리해보자면 DTO가 필요한 이유는 다음과 같다.
1. 필요한 데이터를 묶어 하나의 요청으로 보내어 호출 비용을 최소화하고, 검증, 로직 처리를 한 번에 할 수 있다.
2. 엔티티 내부 구현을 캡슐화 할 수 있다(불필요한 속성이나 메소드를 감춤).
3. validation 코드와 모델링 코드를 분리할 수 있다(Nest의 경우 어노테이션으로 타입 검증 가능).
4. 순환참조를 예방할 수 있다(이 부분은 겪어보지 않아 잘 모르겠다).

### DAO와의 차이
- DAO란 Data Access Object의 약자로 실제 DB에 접근하는 객체다. 이름부터가 Access가 들어가니 무슨 역할을 하는지는 직관적이다. DTO가 계층간 데이터 이동을 위한 Wrapper라면, DAO는 오직 Persistent를 위해서만 사용한다.
- 이를 이해하기 위해선 커넥션 풀(connection pool)이란 것도 알아두면 좋다.
- 커넥션 풀이란 웹서버는 DB와 연결하기 위해 매번 커넥션 객체를 생성하는데, 이런 커넥션 객체를 미리 만들어 놓고 그것을 사용하는 것을 말한다.
- 유저가 CRUD 게시판을 사용한다고 하면 게시물을 읽을 때나 게시판을 조회할 때나 적지 않은 DB와의 커넥션이 일어난다. 그러나 이를 위해 계속 커넥션을 생성하는 것은 매우 비효율적인 일이다. 이런 오버헤드를 효과적으로 관리하기 위해 DB에 접속하는 객체를 전용으로 하나만 만들고 모든 페이지에서 그 객체를 호출하여 사용하는데, 이렇게 커넥션을 하나만 가져오고 그 커넥션을 가져온 객체가 모든 DB와의 연결을 하는 것이 DAO객체이다.
- 즉, <b>쉽게 말하여 DAO는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 의미</b>한다.

## 대용량 트래픽 처리에 대한 이해 
ex) "3000번째로 클릭한 사람에게 포르쉐를 주는 이벤트를 하는데 순간 동시접속자 수는 대략 백만명이 넘어갈 것으로 예상된다. 이 동시접속하는 백만명의 요청 중에서 어떻게 3000번째를 구분할 것인가? "

## NoSQL에서 스키마 필드를 추가, 제거 하는 등의 변경이 일어날 경우 기존 데이터에 어떻게 적용할 것인지
### NoSQL은 Schemaless?
- NoSQL의 특성 중 하나는 유연한 스키마 구조이다. 그러나 이는 스키마가 없다는 것(Schemaless)이 아니라, RDB의 스키마 보다 유연하고 탄력적인 스키마를 의미한다. 
- RDB가 ALTER 쿼리를 사용해서 스키마를 변경한다면, NoSQL은 그저 필드를 추가하는 것으로 스키마가 반영되어 저장된다.

### mongoDB의 필드 추가, 제거
- 일단 내가 알고 있는 NoSQL은 mongoDB 밖에 없으므로 이를 예시로 들자.
- 몽고db는 $unset, $set 연산자가 존재한다. mongoose ODM으로만 몽고db를 다뤄봐서 ODM에선 이를 어떻게 적용할지 아직 모르지만 $set은 특정 도큐먼트에 추가할 필드와 그 값을 지정하여 업데이트할 수 있다. 이는 모든 도큐먼트에도 가능하고, 특정한 하나의 도큐먼트에만 적용하는 것도 가능하다.
- $unset의 경우 $set과는 반대로 특정 도큐먼트 혹은 모든 도큐먼트의 특정 필드를 제거할 수 있다. 제거할 필드를 지정하고 그 값을 1로 지정하면 해당 필드를 제거할 수 있다.

### 데이터의 버전관리?
- 그러나 위와 같은 방법은 스키마의 필드를 추가, 제거할 수는 있으나 사용자가 필요할 때마다 변경하는 것이므로 전체적인 관점에서 봤을 때 올바른 데이터관리라고는 보기 어려울 것이다. 
- 그렇다면 버전 값을 적용해보는 것은 어떨까? 초기 스키마의 데이터 버전은 0에서 시작하여 1 혹은 0.1 씩 증가시키는 것 말이다.
- 데이터의 스키마를 변경하기로 할 때마다 특정 문서에서 스키마의 버전 값을 읽어오고, 데이터들의 버전 값을 확인하여 버전이 다를 경우 변경된 버전에 맞게 변경하는 함수를 호출하는 것이다.
- 예를 들어 유저 정보 스키마에 적립금이란 스키마가 추가된다면 해당 유저 정보가 호출됐을 때 스키마 버전이 이전 버전일 경우 적립금 필드를 추가하는 것이다(적립금은 이제 추가되는 것이므로 당연히 0원에서 시작할 것이다).
- 그러나 누군가 해당 유저 정보를 호출할 때마다 버전 체크를 하는 것은 굉장히 불필요한 일일 것이다. 그러므로 최선의 방법은 DB관리자가 DB에 변경이 있을 경우 이를 일괄변경하도록 하고, 버전 필드는 혹시 모를 에러를 위한 조치 혹은 일정 주기마다 데이터를 업데이트할 경우 참조하기 위한 수단으로 두면 좋을 것 같다.

## MSA(Microservices Architecture)
### MSA란?
- 마이크로 서비스 아키텍쳐의 약자로, 단일 프로그램을 각 컴포넌트 별로 나누어 작은 서비스의 조합으로 구축하는 방법. 
- 각 컴포넌트는 서비스 형태로 구현되고(작은 서비스들로 나눠짐) API를 이용하여 타 서비스와 통신함.
- 전체 어플리케이션을 특정 목적을 가진 어플리케이션 단위로 나누는 것. 어플리케이션 간 약한 결합도와 강한 응집도를 목표로 함.
- 나눠진 어플리케이션들이 각각 독립적으로 나누어지기 때문에 배포 또한 독립적으로 가능해짐.
- 각 어플리케이션은 독립적이고 API로 소통하므로 환경(프로그래밍 언어, 프레임워크 등) 또한 제각각으로 구성 가능.
- 일부 기능에 변경이 있다면 해당 부분 어플리케이션만 재배포, 재시작하면 됨. 
- 에러가 발생한다면 해당 에러가 전체 시스템에 영향을 끼치지 않음.
- 코드 복잡성 및 의존성을 제거하여 영향도 파악을 용이하게 함.

### 모놀리식(Monolithic) 구조
- 전체 어플리케이션은 단일 단위로 설계되고 개발 및 배포됨(하나로 뭉쳐짐).
- MSA가 API를 호출하여 서로 통신한다면 모놀리식은 네트워크를 사용하지 않고 단순히 내부 함수 호출로 통신 가능.
- 일반적으로 전체 어플리케이션이 단일 프로그래밍 언어로 작성됨.
- 일부 기능에 변경이 있다면 전체를 다시 재배포, 재시작 해야함.
- 에러가 발생한다면 해당 에러가 전체 시스템에 영향을 끼칠 수 있음.

## 모놀리식 구조 문제점
- 부분 장애가 전체 서비스로 전파된다.
- 부분적인 서비스의 scale-out이 어렵다.
- 서비스의 개선이 어렵고, 수정 시 장애의 영향도 파악이 어렵다. 
- 서비스의 전체 코드가 하나의 프로젝트로 구성되어 배포가 오래걸린다.
- 하나의 framework와 개발언어에 종속되어 서비스에 적절한 기술을 사용하기 어렵다. 

### MSA의 단점 
- 한 트랜잭션의 처리 및 각각의 어플리케이션 에러에 대한 처리가 필요. 한 트랜잭션에 여러 어플리케이션이 상호작용 해야 한다면 그에 대한 처리나 에러 처리가 복잡해짐.
- 어플리케이션의 숫자가 많아질수록, 복잡해질수록 테스트가 어려워짐.
- 모놀리식 구조에 비해 네트워크 레이턴시와 트래픽이 증가함. 모놀리식 구조가 각 서비스가 하나의 어플리케이션에 뭉쳐있기에 내부 함수를 호출하는 식으로 통신이 가능했다면, MSA 구조는 각각 독립적으로 나뉘어 API로 통신하기에 네트워크 호출이 증가하며 그에 따른 트래픽이 증가함.
- 각각의 어플리케이션의 데이터 무결성을 책임지지 못함.

## MVP(Minimum Viable Product)

## SDLC(소프트웨어 생명주기)

## gRPC Gateway

## gateway layer?
-rails를 없애고 gateway layer를 추가하는 이유?

## API Gateway

## GCDN
-GSLB?

## WAS?

## Logging Platform

## 배포없이 특정 기능에 대한 폴백(fallback)

## ruby on rails로 개발된 모놀리틱 구조

## ruby on rails 모놀리틱 구조 뒤에 kotlin, spring을 사용한 msa구조

## 개발 서버와 프로덕션 서버

## 개발 패턴
-FACADE 패턴

## 클라우드 오토 스케일링?

## Scale up, Scale out
