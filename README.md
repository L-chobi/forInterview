
## Node.js 
- 서버에서 자바스크립트를 동작할 수 있도록 하는 플랫폼
- Node.js 라이브러리의 API는 모두 비동기(fetch, axios 등).
- node는 싱글 스레드 기반 비동기 IO처리를 함. 싱글 스레드이기 때문에 동기화 처리 등의 복잡한 과정을 생략가능
- 자바에 비해 러닝 커브가 낮으나 그만큼 코드 작성이 자유롭기에 구조적이지 않아 자바 언어에 비해 코드 가독성이 낮을 수 있음. 이는 유지 보수가 어려워진다는 것을 의미
- 멀티 코어 머신에서 CPU 사용을 최적화할 수 없음

## Node와 Javascript의 차이?
- 기존 자바스크립트의 경우 독립적인 언어가 아닌 스크립트 언어로써 웹 브라우저가 없으면 사용할 수 없는 단점이 존재했다. 즉, client 개발을 위한 용도로만 사용되었었다. 이제 여기서 브라우저에서만 쓰는 게 아니라 내 컴퓨터에서 다양한 용도로 확장하기 위해 만들어진 것이 Node.js다. 즉, 자바스크립트가 프로그래밍 언어의 한 종류라면 노드는 브라우저 밖의 자바스크립트 런타임(프로그램이 실행되고 있을 때 존재하는 곳)이라고 할 수 있다.
- 만약 에디터를 써 자기 컴퓨터에서 자바스크립트를 사용하는 것도 노드가 있기에 가능하다는 것이다.
- 자바스크립트 자체적으로는 브라우저에서만 동작하며 document를 다루지만 노드를 사용한다면 데스크탑에서도 동작이가능하고 document 뿐만 아니라 서버개발이 가능하게 해준다.

## 자바스크립트
### 인터프리터 언어
- 인터프리터 언어란 번역(하이레벨 언어->기계어)과 실행을 순차적으로 동작시키는 언어를 인터프리터 언어라고 부름. 번역과 실행이 거의 동시에 실행되기에 1개의 액션이 존재하고 별도의 실행파일이 없음. 자바스크립트, 루비, 파이썬, PHP 등.
- 인터프리터 언어는 컴파일 언어에 비해 잦은 수정이 발생해도 매번 컴파일 할 필요가 없음. 그러나 번역과 실행을 하나의 액션에서 실행하므로 약간의 처리능력이 필요.
- 컴파일 언어란 실행 이전에 번역 작업을 하는 언어를 말함. 하이레벨 언어를 번역하고, 번역된 코드를 실행하는 2개의 액션이 존재. 컴파일을 하게 되면 실행가능한 프로그램이 생성됨. 이렇게 생성된 프로그램은 인터프리터를 이용해 실행시키는 것보다 빠름. 다만 소스코드가 클 경우 컴파일 시간이 오래 걸림. C, C++, JAVA 등
- 컴파일 언어의 장점은 컴파일한 운영체제의 사양에 최적화되어 실행되므로 속도가 빠르고 버그 발견이 용이. 그러나 실행환경(지정된 운영체제)에 최적화되게 만들어져있어 다른 운영체제에서 실행하기 위해선 재컴파일이 필요하고 코드의 일부가 바뀌어도 전체 코드를 재컴파일해야함.

### 자바스크립트는 인터프리터 언어?
- 자바스크립트 엔진은 전통적인 인터프리터일 수도 있고, 특정한 방식으로 바이트코드로 JIT 컴파일을 할 수 있다.
- 보통은 인터프리터 언어라고 말하지만 자바스크립트도 컴파일 과정을 거친다. 크롬 V8 엔진의 경우 엔진이 실행할 JS 파일을 받은 후 파싱, AST(Abstract Syntax Tree)를 구축하고, 다음으로 인터프리터가 코드를 읽으며 실행한다. 코드를 수행하는 과정에서 프로파일러가 최적화할 수 있는 코드를 컴파일러에게 전달하면, 주로 반복해서 실행되는 코드 블록을 컴파일(최적화)함. 그 후 원래 있던 코드와 최적화된 코드를 바꿔줌. 
- 이런 식으로 코드를 우선 인터프리터 방식으로 실행하고 필요할 때 컴파일 하는 방법을 JIT(Just In Time) 컴파일러라고 부름. 즉, 자바스크립트는 실행되는 플랫폼에 따라 인터프리팅과 컴파일이 혼합되어 사용됨.

#### AST?
- 우리말로 옮기면 추상 구문 트리. 소스코드의 추상 구문 구조를 표현하기 위해 사용됨. 즉, 특정 프로그래밍 언어로 작성된 프로그램 소스 코드를 각각 의미별로 분리하여 컴퓨터가 이해할 수 있는 구조로 변경시킨 트리를 의미.

### var, let, const의 차이
- 일단 세 방식 모두 정해진 스코프를 벗어나면 사용할 수 없다. 다만 함수가 아닌 곳에서 var a = 1 를 선언했는데  어떤 함수에서 var a = 5를 선언하면 처음에 선언한 a가 전역변수로 취급되어 함수를 벗어났음에도 a의 값은 5가 된다.
- var: 함수 스코프를 가지고 재선언(중복 선언)해도 에러가 발생하지 않음. 변수 선언과 초기화가 한 단계에 이루어지기 때문에 값을 할당안해도 undefined라고 출력되고 에러가 발생하지 않음(let, const는 할당). 오직 함수 코드 블록만을 지역 스코프로 인정함.
- let: 블록(if, for, while 블록 등) 스코프를 가짐. 재할당은 가능하지만 재선언은 불가능. 해당 블록을 벗어나면 사라짐. 함수 외에도 if문, for문 등을 블록으로 인정.
- const: 블록 스코프를 가지고 상수를 선언할 때 사용. 선언과 동시에 할당되며 재할당 불가능(반드시 선언과 초기화를 동시에 진행해야 함). 블록 레벨 스코프를 지원. 원시 타입의 값은 변경 불가능하지만 객체는 가능하기에 불변을 의미하지는 않음

### 호이스팅(hoisting)
- 기본적으로 호이스트는 변수의 정의가 그 범위에 따라 선언/초기화/할당/분리되는 것을 의미
- 호이스팅은 함수 안에 있는 선언들을 모두 끌어올려서  해당 함수 유효 범위의 최상단에 선언하는 것을 말함. 필요한 값들을 위로 끌어올리는 것. 
- 자바스크립트 엔진은 코드를 실행하기 전 실행 가능한 코드를 형상화하고 구분하는 과정을 거치는데, 이때 var, let, const, function 등을 스코프에 등록한다. 코드 실행 전부터 이미 변수/함수선언이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나오더라도 오류 없이 동작한다. 그러나이는 var로 선언한 변수/함수만 해당된다. let으로 선언된 변수는 스코프의 시작에서 변수의 선언까지 TDZ(Temporal Dead Zone, 일시적 사각지대)에 빠지기 때문이다.
- 변수는 선언->초기화->할당 단계에 걸쳐 생성되는데 var의 경우 선언과 초기화 단계가 한번에 이루어진다. 그러나 let의 경우 선언과 초기화 단계가 분리되어 진행된다. 그렇기에 var은 초기화를 하지 않아도 undefined 값을 가지는 것을 볼 수 있지만 let의 경우 호이스팅을 통해 변수가 선언되어도 선언문에서 초기화 단계가 실행되기 때문에 그전까지는 참조할 수 없다. 이는 const도 마찬가지이나 const의 경우 바로 값을 할당해줘야 한다.

### 클로저(closure)
- 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여 그 스코프 밖에서 호출되어도 해당 스코프에 접근할 수 있는 함수를 말함
- a라는 함수가 존재하던 스코프에 b라는 변수가 있을 때, 그 스코프 밖에서 a를 호출하면 a 함수가 b 변수에 접근할 수 있는 경우를 말함

### call, bind, apply
- 위 세개 모두 함수 호출 방법에 이용된다. 보통 함수 호출은 함수 이름 뒤에 ()를 붙이거나 call, apply를 사용하여 호출하는 방법이 있다. call, apply는 각각 function.call(arguments), function,apply(arguments)처럼 사용된다.
#### call
- func.call(thisArg[, arg1[, arg2[, ...]]])
- call의 첫 매개변수에는 thisArg가 들어가는데, 이 thisArg라는 것은 각 함수의 실행문맥의 this를 특정하게 지정하는 매개변수를 의미한다. 그 뒤 부터는 호출할 함수에 필요한 변수들이 들어간다.
#### apply
- fun.apply(thisArg, [argsArray])
- thisArg는 call과 같고, argsArray는 call처럼 호출할 함수에 필요한 변수지만 apply의 경우에는 이 변수를 배열 형태로 넣게 된다.
#### bind
- func.bind(thisArg[, arg1[, arg2[, ...]]])
- thisArg는 call, apply와 같고 그 뒤의 인수는 call과 같다. 다만 bind의 경우 새롭게 함수를 만든다. bind는 call, apply처럼 함수가 가리키고 있는 this를 바꾸지만 호출은 하지 않는다. 그렇기에 따로 let arg = bindFunction ... bindFuntion() 처럼 변수를 할당하여 호출하는 형태로 사용된다.

### 실행 문맥?
- 콜 스택과 유사한 역할을 수행한다. 다만 방식이 조금 다른데, 보통의 경우 함수를 호출할 때 필요한 정보는 콜 스택에 쌓이게 되며 그 정보는 매개변수, 종료 후 복귀 주소, 지역 변수 등을 말한다. 실행 문맥도 비슷하나 추가적으로 리스트 형태의 스코프 체인이라는 것을 저장하고 있다. 스코프 체인은 실행 문맥들이 연결된 리스트이며, 현재 실행 문맥에서 다른 문맥의 변수에 접근하도록 도와준다.
- 이후 다른 문맥의 식별자를 찾을 때 스코프 체인의 변수 객체를 순차적으로 방문하면서 찾고자하는 식별자가 존재하는지 확인한다.
- 가장 최초로 생성되는 문맥은 전역 실행 문맥이다. 그냥 js 파일을 만들었을 때의 문맥이라고 생각하면 편하고, 이후 정의된 함수가 실행될 때마다 문맥이 추가되며 스코프 체인도 해당 문맥과 결합된다.

### 이벤트 루프(event loop)
#### 자바스크립트는 단일 스레드 기반 언어?
- 자바스크립트는 단일 스레드 기반의 언어로 한 번에 하나의 작업만을 처리할 수 있다. 비동기로 동작하기 때문에 단일 스레드임에도 불구하고 동시에 많은 작업을 수행한다(이는 다음 설명에 보충).
- 그러나 비동기로 동작하는 핵심 요소는 자바스크립트가 아닌 브라우저가 가지고 있다. 노드는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하는데, 이 libuv 라이브러리가 이벤트 루프를 제공한다. 
- 자바스크립트 엔진은 비동기 작업을 위해 노드의 API를 호출하며, 이때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.
- 자바스크립트가 단일 스레드 기반 언어라는 말은 '자바스크립트 엔진이 단일 호출 스택을 사용한다'는 관점에서만 사실이다. 실제 js가 구동되는 환경(브라우저, node 등)에서는 주로 여러 개의 스레드가 사용되며, 이러한 구동 환경이 단일 호출 스택을 사용하는 js엔진과 상호 연동하기 위해 사용하는 장치가 '이벤트 루프'이다.

#### 선행 지식과 이벤트 루프란
- 자바스크립트 엔진은 힙과 콜 스택을 가지고 있다. 힙(Heap)은 메모리 할당이 발생하는 곳이고, 콜 스택(Call Stack)은 실행된 코드의 환경을 저장하는 자료구조로, 함수 호출 시 이곳에 저장된다. 어떤 함수를 저장하면 스택에 쌓고 또 다른 함수를 호출하면 그 다음 스택에 쌓이면서 가장 위에 쌓인 함수를 가장 먼저 처리한다(LIFO).
- 브라우저가 제공하는 것에는 Web APIs가 있다. 브라우저가 제공하는 API로 DOM, Ajax, TimeOut 등이 있다. 콜 스택에서 실행된 비동기 함수는 Web API를 호출하고, Web API는 콜백 함수를 태스크 큐(Task Queue)에 넣는다. 
- 태스크 큐(혹은 콜백 큐)는 함수를 저장하는 자료구조로, 이벤트 루프는 호출 스택(콜 스택)이 비워질 때마다 태스크 큐에서 콜백 함수를 꺼내와서 콜 스택으로 옮기는 역할을 한다.
- 이벤트 루프는 현재 실행중인 태스크가 없는지(콜 스택이 비워졌는지 등), 태스크 큐에 태스크가 있는지를 반복적으로 확인한다.


### 가비지 컬렉션
- 쓸모 없어진 객체가 차지하는 메모리를 자동으로 해제하는 것을 말함. js, java, python은 가비지 컬렉터가 자동으로 메모리륽 관리해줌. c, c++ 등 수동으로 메모리를 관리하는 언어는 기본적으로 가비지 컬렉터가 없음.
#### 장점
- 메모리를 완벽하게 관리하지 않아도 가비지 컬렉션이 알아서 관리함
#### 단점
- 언제 가비지 컬렉션이 진행될지 모름. 객체가 쓸모없어지는 시점에 정확히 메모리가 해제되지 않기 때문에 최적의 메모리 관리는 어려움
- 가비지 컬렉터가 어떤 객체가 쓸모 없는지 판단하는 데에 시간이 소요됨. 즉, 동작하는 시간이 발생.

### express 미들웨어에서 next(), next(’route’), return next()의 차이
- next()는 현재에서 즉시 응답을 내리지 않고 응답처리를 다음 미들웨어나 라우터로 실행을 넘김. 
- next(’route’)는 현재 메소드를 벗어나 path에 해당하는 다음 라우터로 제어가 넘어가는 것. 즉, 해당 라우터의 다른 미들웨어를 실행하지 않고, 현재 라우팅 주소와 일치하는 다음 라우터로 넘어감
- return next()는 next()를 실행하고 return next()를 호출한 블록을 즉시 종료시킴(next와는 이 부분이 다름)

### app.use와 app.get의 차이
- app.use는 해당 경로로 get,put,post 등의 모든 종류의 요청을 처리
- app.get은 해당 경로에서 get 요청만 처리.

### 원시타입(Primitive Type 변수)
- number, string, boolean, null, undefined, symbol(symbol은 잘 못봤다)
- 원시 타입 데이터는 불변하는 데이터로, 메모리를 한번 할당받으면 값이 변경되지 않는다. 
- c의 경우 변수에 값을 재할당하면 변수가 가리키고 있는 메모리주소의 값이 변경됨. 그러나 js의 경우 값을 재할당하면 새로운 메모리 공간을 할당받아 값을 넣고, 변수가 가리키는 메모리주소를 변경함. 즉, 이전 메모리 공간은 쓸모없어져 가비지 컬렉션 대상이 됨.

### 객체 타입(Object Type)
- 원시 타입을 제외한 모든 것(객체, 배열, 함수 등)
- 객체 타입을 변수에 할당하면, 변수에는 실제 객체가 저장된 힙 메모리 주소가 저장됨.
- 객체 타입을 담은 변수를 다른 변수에 할당하면 메모리 주소를 공유하기 때문에 같은 객체를 가리킴(=== 연산 결과 true).
- 만약 스프레드 연산자(...variable) 등의 방법으로 객체를 복사해서 새로운 변수에 할당하면 객체의 구성은 같을 수 있어도 메모리 주소가 다르기에 서로 다른 객체가 됨(=== 연산 결과 false)
- js 객체에 접근하는 방법은 메모리 주소를 통하는 것으로, c의 포인터와 비슷한 느낌임. 그렇기에 객체를 가리키는 포인터가 하나도 없으면 객체를 사용할 방법이 없는 것이므로 가비지 컬렉션의 대상이 됨.

### 제네릭(Generic)
- 제네릭이란 데이터의 타입을 일반화한다는 것을 뜻한다.
- 자료형을 정하지 않고 여러 타입을 사용할 수 있게 해주는데, 즉 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 해주는 기법이다. 재사용이 가능하다는 점이다.
- 보통 함수나 클래스, 인터페이스 등을 사용하게 될 때 여러 종류의 타입에 대해 호환을 맞춰야하는 상황에서 사용한다. 
- any를 쓸 수도 있지만 any를 사용하게 되면 타입추론이 모두 깨진 것과 다름이 없다. 제네릭은 클래스와 비슷하게 틀의 역할을 하지만 그 내용물(타입)은 다른 느낌이다.
- 사용은 <T>로 사용한다. getVariable<T>(variable: T): T, 이런 식으로 기존 타입 대신 T를 넣는다. getVariable이란 함수에 variable 변수를 주어 호출하면 이 variable 변수의 타입이 T로 지정되어 나머지 T들도 그와 같은 타입으로 쓰이게 된다.

## 타입스크립트
- 이름은 js와 비슷한데 js와 다르게 컴파일 언어라고 한다. 그런데 c계열과는 차이가 있어 트랜스파일 언어라고도 부른다. 정적 타입 언어이기에 컴파일 시간이 조금 걸리지만 안전성이 보장된다.
- 동작은 TS -> 컴파일(트랜스파일) -> JS -> 실행으로 이루어진다. TS가 JS로 자동변환될 때 helper 코드가 위 아래로 추가되어 절대적인 코드의 양은 ts가 더 많다.
  
### 특징
  - 클래스와 인터페이스를 지원하여 완전한 객체지향 프로그래밍 환경을 제공. 그러나 java처럼 다중 생성자를 선언할 수는 없음. 또한 java와 다르게 디폴트 초기화 매개변수와 선택 매개변수를 선언할 수 있음.
  - js의 타입을 확장하고 타입 어노테이션을 이용해서 변수에 타입을 선언할 수 있게함. 엄격한 타이핑이 적용되어 타입의 안전성이 확보됨
  - 조기 버그를 감지. 컴파일을 거치기 때문에 컴파일러가 코드를 검사하여 런타임 시 버그 및 예기치 못한 동작의 가능성이 줄어듦.
  - ES6에서 제공하는 모듈 선언과 모듈 호출 방식을 지원. 라이브러리 단위의 모듈 구성에 유리
  - 유지 관리가 쉽고 코드 구성에 적합하여 프로젝트 생산성을 향상시킴.
  
#### 개인적인 느낌
  - 최근 Nedio라는 프로젝트의 백엔드를 nest 프레임워크로 작성했는데 자바스크립트와 익스프레스로 구성했던 것과 다르게 굉장히 구조화된 느낌을 받았다(각 그룹 당 모듈, 컨트롤러, 서비스 파일이 존재했다). 스프링과 굉장히 유사한 방식이라고 어디서 들었는데, 확실히 규모가 큰 프로젝트를 만들 때 강제로 구조를 잡아줘 유리할 듯 하다.
  
### 프로세스 메모리 올라갈때 스택과 힙?
- 프로세스가 메모리에 올라갈 때, 운영 체제는 프로세스에게 독립한 메모리 영역을 할당해 주는데, 이때 코드, 데이타, 스택, 힙 형식으로 할당해줌.
- 코드 영역에는 말 그래도 프로그램 코드가 기계어로 바뀌어서 있고, 데이터 영역에는 전역 변수, 배열 등이 있음. 
- 힙은 프로그래머가 동적으로 사용하는 영역. malloc(), new() 같은 걸로 할당하고 반환. 
- 스택에는 지역 변수, 매개 변수, 리턴 값 등 잠시 사용되고 사라지는 임시 데이터가 존재.
- 스택 영역은 프로그램이 자동으로 사용하는 임시 메모리 영역. 함수의 호출과 함께 할당되고 함수 호출이 완료되면 소멸(지역변수, 매개변수 등). 컴파일 타임에 크기가 결정됨.
- 힙은 사용자가 동적으로 할당, 해제함. 런타임에 크기가 결정됨.

### 스택 오버 플로우? 힙 오버 플로우
- 힙은 메모리 위쪽 주소에서 부터 할당되고 스택은 메모리 아래쪽 주소부터 할당되기 때문에 각 영역이 상대 공간을 침범하는 현상이 발생. 힙이 스택을 침범하면 힙 오버 플로우, 반대면 스택 오버 플로우
 
### 컨텍스트 스위칭?
- cpu는 여러 프로세스를 처리. cpu에서 여러 프로세스들이 돌아가면서 작업을 처리하는데, 이때 다른 프로세스를 처리하게 될 때, 그때까지 실행되던 프로세스들의 상태 정보를 저장하는 장소가 필요해짐.
- 프로세스들은 대기하면서 해당 프로세스의 상태를 가지고 있다가 대기하고 있던 그 프로세스의 차례가 되면 이전에 저장해뒀던 프로세스 상태를 복구함. 이 과정을 context switching이라고 .
  
## 패턴
### MVC Pattern
- DB와 직접적인 상호작용을 관리하는 Model, 프론트에서의 구현 사항들을 제공해주는 View, 유저의 요청을 처리하거나 API가 실행되는 등의 실제 동작하는 로직이 담겨져있는 Controller로 구현하는 아키텍처를 말함.
- 이는 각각 역할과 책임을 분리하기 위한 패턴으로, 각 레이어(단)마다 담당할 책임과 역할을 나눠 동시적인 개발, 수정의 용이함, 테스트를 원활하게 할 수 있게 한다.

### MVP Pattern
- 기존 MVC의 Controller 대신 Presenter를 합친 패턴이다. 기존의 Model, View는 동일하다.
- MVC의 경우 사용자의 액션이 컨트롤러로 들어와 컨트롤러가 액션에 따라 모델을 업데이트하고, 컨트롤러는 모델을 나태줄 뷰를 선택하면 그 뷰가 모델을 이용해 화면을 업데이트한다. 즉, 모델과 뷰간 의존성이 존재하며 컨트롤러는 방향만 지시해주는 모습이다. 이런 높은 의존성은 어플리케이션이 커질 수록 복잡해지고 유지보수를 어렵게 한다.
- MVC에서 View가 Controlle의 존재를 몰라도 되었다면 MVP에서는 모델과 뷰가 프레젠터를 활용한다. 액션이 뷰를 통해 들어오면 뷰는 데이터를 프레젠터에 요청하고, 프레젠터는 모델에게서 해당 데이터를 요청한다. 모델이 프레젠터에게 응답하면 프레젠터는 이를 뷰에게 넘겨준다. 뷰는 프레젠터가 응답한 데이터를 이용해 화면을 나타낸다. 이는 MVC와 다르게 프레젠터라는 중간 단계를 적극 활용하여 모델과 뷰 간 의존성이 사라진 느낌이다.
- 다만 모델과 뷰 간 의존성이 사라졌다면 MVP에서는 뷰와 프레젠터 사이의 의존성이 높아지게 되었다.

## REST
### RESTful API
- REST(Representational State Transfer)란 웹에 존재하는 모든 자원에 고유한 URI(이름)를 부여하여 자원에 대한 주소를 지정하는 방법론 또는 규칙이다. REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
- 구체적인 개념은 HTTP URI를 통해 자원을 명시하고, HTTP Method(GET, POST, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation(Create, Read, Update, Delete)을 적용하는 것을 의미한다. 쉽게 말해 HTTP URI로 조작할 자원의 이름을 정의하고 HTTP Method로 수행할 조작을 선택하여 조작하는 것을 말한다("김치찌개"를 "먹는다" 처럼).
- Restful API는 REST 특징을 지키면서 API를 제공한다는 의미이다. 
- JSON 혹은 XML을 통해 데이터를 주고 받는 것이 일반적이다.

### RESTful?
- 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다. 즉, REST API를 제공하는 웹 서비스를 RESTful하다고 할 수 있다. REST의 원리를 따르는 시스템은 RESTful 하다는 뜻이다.

### 장점
- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API를 사용하기 위해 별도의 인프라를 구축할 필요가 없다.
- HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용이 가능하다.
- 의도하는 바를 명확하게 나타내므로 의도를 쉽게 파악할 수 있고 서버와 클라이언트의 역할을 명확하게 분리한다.

### 단점
- 사용할 수 있는 메소드가 4가지(GET, POST, PUT, DELETE)이다. 
- 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다고 한다.

### URL과 URI의 차이
- URL은 Uniform Resource Locator의 약자이다. 흔히 웹주소라고 하며 컴퓨터 네트워크 상에서 리소스가 어디 있는지 알려주기 위한 규약이다. URI의 서브셋이라고 한다.
- URI는 Uniform Resource Identifier의 약자이다. 특정 리소스를 식별하는 통합 자원 식별자를 의미하는데, 웹 기술에서 사용되는 논리적 또는 물리적 리소스를 식별하는 고유 문자열 시퀀스다.
- URI는 식별하고, URL은 위치를 가르킨다. URL이 자원이 실제 존재하는 위치를 가리킨다면 URI는 자원의 위치뿐만 아니라 자원에 대한 고유 식별자로서 URL의 의미를 포함한다.

## ORM
### ORM이란?
- Object-relational-mapping의 약어. 데이터 하나를 하나의 객체로 생각하겠다는 것에서 출발한 개념이다. 그러나 자바의 객체와 자바스크립트의 객체가 다르듯 각 언어의 객체가 다르기에, 각 언어에 적합한 객체의 형태로 데이터를 반환해주는 역할을 하는 것을 ORM이라고 한다.
- 좀 더 기능적으로 설명하면 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다. 자바와 같은 OOP(Object-Oriented Programming 객체 지향 프로그래밍) 언어는 클래스를 사용하고, 관계형 데이터베이스(SQL 등)는 테이블을 사용하는데 여기서 객체 모델과 관계형 모델 간에 불일치가 존재한다. 이런 불일치를 ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다. 즉, 직접 SQL 쿼리를 짜는게 아닌 객체를 통해 간접적으로 DB를 다룰 수 있게 된다.
- 그러나 어플리케이션이 커질수록 효율이 떨어지기에 그럴 경우 SQL을 사용하는 것이 효과적이라고 한다.
- 재사용, 유지보수가 편리하다고 하며 DBMS에 대한 종속성이 낮다고 한다. 객체 지향적 코드로 직관적이지만 복잡성이 올라갈수록 난이도가 높아지며 프로시저가 많은 시스템은 전환하기 어렵다.
- JPA, Hibernate, Sequelize, myBatis 등이 여기에 속한다.

### ODM?
- ORM이 RDB(관계형 데이터베이스)를 효과적으로 다루기 위해 만들어졌다면 ODM(Object-Document Mapper)은 NoSQL에서 Document(문서형) DB를 지원하기 위해 만들어졌다.
- NoSQL이란 RDB 뿐만 아니라 다양한 DB를 명칭하는데, 빅데이터를 다룰 때 RDBMS로만 트래픽을 감당하기 어려워져 이를 해결하기 위해 탄생했다고 한다. NoSQL의 DBMS 중 MongoDB가 가장 많이 사용되며, 이 MongoDB에 대한 ODM으로 mongoose가 있다(ORM은 안써봤고 mongoose로 ODM을 써봤는데 진짜 편하긴 하더라. ORM도 비슷한 느낌일 듯 하다).
- Join이 없으므로 Join 연산이 필요 없도록 데이터 구조화가 필요하다. 스키마 없는 DB를 이용하여 빠르게 개발할 수 있다(실제로 스키마를 작성해도 나중에 스키마에 없는 속성이 들어간 데이터를 넣으면 오류가 발생하지 않고 들어간 것을 확인할 수 있다). 
- ORM이 수직적으로 확장이 좋다면 ODM은 수평적 확장성이 좋다고 한다.

### es6란?
ecmascript2016 버전. 그동안 불편했던 점들을 개선(let, const, arror function 등)
