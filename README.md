
## Node.js 
- 서버에서 자바스크립트를 동작할 수 있도록 하는 플랫폼
- Node.js 라이브러리의 API는 모두 비동기(fetch, axios 등).
- node는 싱글 스레드 기반 비동기 IO처리를 함. 싱글 스레드이기 때문에 동기화 처리 등의 복잡한 과정을 생략가능
- 자바에 비해 러닝 커브가 낮으나 그만큼 코드 작성이 자유롭기에 구조적이지 않아 자바 언어에 비해 코드 가독성이 낮을 수 있음. 이는 유지 보수가 어려워진다는 것을 의미
- 멀티 코어 머신에서 CPU 사용을 최적화할 수 없음

## 자바스크립트
#### 인터프리터 언어
- 인터프리터 언어란 번역(하이레벨 언어->기계어)과 실행을 순차적으로 동작시키는 언어를 인터프리터 언어라고 부름. 번역과 실행이 거의 동시에 실행되기에 1개의 액션이 존재하고 별도의 실행파일이 없음. 자바스크립트, 루비, 파이썬, PHP 등.
- 인터프리터 언어는 컴파일 언어에 비해 잦은 수정이 발생해도 매번 컴파일 할 필요가 없음. 그러나 번역과 실행을 하나의 액션에서 실행하므로 약간의 처리능력이 필요.
- 컴파일 언어란 실행 이전에 번역 작업을 하는 언어를 말함. 하이레벨 언어를 번역하고, 번역된 코드를 실행하는 2개의 액션이 존재. 컴파일을 하게 되면 실행가능한 프로그램이 생성됨. 이렇게 생성된 프로그램은 인터프리터를 이용해 실행시키는 것보다 빠름. 다만 소스코드가 클 경우 컴파일 시간이 오래 걸림. C, C++, JAVA 등
- 컴파일 언어의 장점은 컴파일한 운영체제의 사양에 최적화되어 실행되므로 속도가 빠르고 버그 발견이 용이. 그러나 실행환경(지정된 운영체제)에 최적화되게 만들어져있어 다른 운영체제에서 실행하기 위해선 재컴파일이 필요하고 코드의 일부가 바뀌어도 전체 코드를 재컴파일해야함.

#### 자바스크립트는 인터프리터 언어?
- 자바스크립트 엔진은 전통적인 인터프리터일 수도 있고, 특정한 방식으로 바이트코드로 JIT 컴파일을 할 수 있다.
- 보통은 인터프리터 언어라고 말하지만 자바스크립트도 컴파일 과정을 거친다. 크롬 V8 엔진의 경우 엔진이 실행할 JS 파일을 받은 후 파싱, AST(Abstract Syntax Tree)를 구축하고, 다음으로 인터프리터가 코드를 읽으며 실행한다. 코드를 수행하는 과정에서 프로파일러가 최적화할 수 있는 코드를 컴파일러에게 전달하면, 주로 반복해서 실행되는 코드 블록을 컴파일(최적화)함. 그 후 원래 있던 코드와 최적화된 코드를 바꿔줌. 
- 이런 식으로 코드를 우선 인터프리터 방식으로 실행하고 필요할 때 컴파일 하는 방법을 JIT(Just In Time) 컴파일러라고 부름. 즉, 자바스크립트는 실행되는 플랫폼에 따라 인터프리팅과 컴파일이 혼합되어 사용됨.

##### AST?
- 우리말로 옮기면 추상 구문 트리. 소스코드의 추상 구문 구조를 표현하기 위해 사용됨. 즉, 특정 프로그래밍 언어로 작성된 프로그램 소스 코드를 각각 의미별로 분리하여 컴퓨터가 이해할 수 있는 구조로 변경시킨 트리를 의미.

#### var, let, const의 차이
- var: 함수 스코프를 가지고 재선언해도 에러가 발생하지 않음.
- let: 블록(if, for, while 블록 등) 스코프를 가짐. 해당 블록을 벗어나면 사라짐
- const: 블록 스코프를 가지고 상수를 선언할 때 사용. 선언과 동시에 할당되며 재할당 불가능

#### 호이스팅(hoisting)
- 기본적으로 호이스트는 변수의 정의가 그 범위에 따라 선언/초기화/할당/분리되는 것을 의미
- 호이스팅은 함수 안에 있는 선언들을 모두 끌어올려서  해당 함수 유효 범위의 최상단에 선언하는 것을 말함. 필요한 값들을 위로 끌어올리는 것. 
- 자바스크립트 엔진은 코드를 실행하기 전 실행 가능한 코드를 형상화하고 구분하는 과정을 거치는데, 이때 var, let, const, function 등을 스코프에 등록한다. 코드 실행 전부터 이미 변수/함수선언이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나오더라도 오류 없이 동작한다. 그러나이는 var로 선언한 변수/함수만 해당된다. let으로 선언된 변수는 스코프의 시작에서 변수의 선언까지 TDZ(Temporal Dead Zone, 일시적 사각지대)에 빠지기 때문이다.
- 변수는 선언->초기화->할당 단계에 걸쳐 생성되는데 var의 경우 선언과 초기화 단계가 한번에 이루어진다. 그러나 let의 경우 선언과 초기화 단계가 분리되어 진행된다. 그렇기에 var은 초기화를 하지 않아도 undefined 값을 가지는 것을 볼 수 있지만 let의 경우 호이스팅을 통해 변수가 선언되어도 선언문에서 초기화 단계가 실행되기 때문에 그전까지는 참조할 수 없다. 이는 const도 마찬가지이나 const의 경우 바로 값을 할당해줘야 한다.

#### 클로저(closure)
- 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여 그 스코프 밖에서 호출되어도 해당 스코프에 접근할 수 있는 함수를 말함
- a라는 함수가 존재하던 스코프에 b라는 변수가 있을 때, 그 스코프 밖에서 a를 호출하면 a 함수가 b 변수에 접근할 수 있는 경우를 말함

#### call, bind, apply
- 위 세개 모두 함수 호출 방법에 이용된다. 보통 함수 호출은 함수 이름 뒤에 ()를 붙이거나 call, apply를 사용하여 호출하는 방법이 있다. call, apply는 각각 function.call(arguments), function,apply(arguments)처럼 사용된다.
##### call
- func.call(thisArg[, arg1[, arg2[, ...]]])
- call의 첫 매개변수에는 thisArg가 들어가는데, 이 thisArg라는 것은 각 함수의 실행문맥의 this를 특정하게 지정하는 매개변수를 의미한다. 그 뒤 부터는 호출할 함수에 필요한 변수들이 들어간다.
##### apply
- fun.apply(thisArg, [argsArray])
- thisArg는 call과 같고, argsArray는 call처럼 호출할 함수에 필요한 변수지만 apply의 경우에는 이 변수를 배열 형태로 넣게 된다.
##### bind
- func.bind(thisArg[, arg1[, arg2[, ...]]])
- thisArg는 call, apply와 같고 그 뒤의 인수는 call과 같다. 다만 bind의 경우 새롭게 함수를 만든다. bind는 call, apply처럼 함수가 가리키고 있는 this를 바꾸지만 호출은 하지 않는다. 그렇기에 따로 let arg = bindFunction ... bindFuntion() 처럼 변수를 할당하여 호출하는 형태로 사용된다.

#### 실행 문맥?
- 콜 스택과 유사한 역할을 수행한다. 다만 방식이 조금 다른데, 보통의 경우 함수를 호출할 때 필요한 정보는 콜 스택에 쌓이게 되며 그 정보는 매개변수, 종료 후 복귀 주소, 지역 변수 등을 말한다. 실행 문맥도 비슷하나 추가적으로 리스트 형태의 스코프 체인이라는 것을 저장하고 있다. 스코프 체인은 실행 문맥들이 연결된 리스트이며, 현재 실행 문맥에서 다른 문맥의 변수에 접근하도록 도와준다.
- 이후 다른 문맥의 식별자를 찾을 때 스코프 체인의 변수 객체를 순차적으로 방문하면서 찾고자하는 식별자가 존재하는지 확인한다.
- 가장 최초로 생성되는 문맥은 전역 실행 문맥이다. 그냥 js 파일을 만들었을 때의 문맥이라고 생각하면 편하고, 이후 정의된 함수가 실행될 때마다 문맥이 추가되며 스코프 체인도 해당 문맥과 결합된다.

## 패턴
### MVC Pattern
- DB와 직접적인 상호작용을 관리하는 Model, 프론트에서의 구현 사항들을 제공해주는 View, 유저의 요청을 처리하거나 API가 실행되는 등의 실제 동작하는 로직이 담겨져있는 Controller로 구현하는 아키텍처를 말함.
- 이는 각각 역할과 책임을 분리하기 위한 패턴으로, 각 레이어(단)마다 담당할 책임과 역할을 나눠 동시적인 개발, 수정의 용이함, 테스트를 원활하게 할 수 있게 한다.

### MVP Pattern
- 기존 MVC의 Controller 대신 Presenter를 합친 패턴이다. 기존의 Model, View는 동일하다.
- MVC의 경우 사용자의 액션이 컨트롤러로 들어와 컨트롤러가 액션에 따라 모델을 업데이트하고, 컨트롤러는 모델을 나태줄 뷰를 선택하면 그 뷰가 모델을 이용해 화면을 업데이트한다. 즉, 모델과 뷰간 의존성이 존재하며 컨트롤러는 방향만 지시해주는 모습이다. 이런 높은 의존성은 어플리케이션이 커질 수록 복잡해지고 유지보수를 어렵게 한다.
- MVC에서 View가 Controlle의 존재를 몰라도 되었다면 MVP에서는 모델과 뷰가 프레젠터를 활용한다. 액션이 뷰를 통해 들어오면 뷰는 데이터를 프레젠터에 요청하고, 프레젠터는 모델에게서 해당 데이터를 요청한다. 모델이 프레젠터에게 응답하면 프레젠터는 이를 뷰에게 넘겨준다. 뷰는 프레젠터가 응답한 데이터를 이용해 화면을 나타낸다. 이는 MVC와 다르게 프레젠터라는 중간 단계를 적극 활용하여 모델과 뷰 간 의존성이 사라진 느낌이다.
- 다만 모델과 뷰 간 의존성이 사라졌다면 MVP에서는 뷰와 프레젠터 사이의 의존성이 높아지게 되었다.

## REST
### RESTful API
- REST(Representational State Transfer)란 웹에 존재하는 모든 자원에 고유한 URI(이름)를 부여하여 자원에 대한 주소를 지정하는 방법론 또는 규칙이다. REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
- 구체적인 개념은 HTTP URI를 통해 자원을 명시하고, HTTP Method(GET, POST, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation(Create, Read, Update, Delete)을 적용하는 것을 의미한다. 쉽게 말해 HTTP URI로 조작할 자원의 이름을 정의하고 HTTP Method로 수행할 조작을 선택하여 조작하는 것을 말한다("김치찌개"를 "먹는다" 처럼).
- Restful API는 REST 특징을 지키면서 API를 제공한다는 의미이다. 
- JSON 혹은 XML을 통해 데이터를 주고 받는 것이 일반적이다.

#### RESTful?
- 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다. 즉, REST API를 제공하는 웹 서비스를 RESTful하다고 할 수 있다. REST의 원리를 따르는 시스템은 RESTful 하다는 뜻이다.

#### 장점
- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API를 사용하기 위해 별도의 인프라를 구축할 필요가 없다.
- HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용이 가능하다.
- 의도하는 바를 명확하게 나타내므로 의도를 쉽게 파악할 수 있고 서버와 클라이언트의 역할을 명확하게 분리한다.

#### 단점
- 사용할 수 있는 메소드가 4가지(GET, POST, PUT, DELETE)이다. 
- 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다고 한다.

### 
