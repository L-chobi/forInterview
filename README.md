
### Node.js 
- 서버에서 자바스크립트를 동작할 수 있도록 하는 플랫폼
- Node.js 라이브러리의 API는 모두 비동기(fetch, axios 등).
- node는 싱글 스레드 기반 비동기 IO처리를 함. 싱글 스레드이기 때문에 동기화 처리 등의 복잡한 과정을 생략가능
- 자바에 비해 러닝 커브가 낮으나 그만큼 코드 작성이 자유롭기에 구조적이지 않아 자바 언어에 비해 코드 가독성이 낮을 수 있음. 이는 유지 보수가 어려워진다는 것을 의미
- 멀티 코어 머신에서 CPU 사용을 최적화할 수 없음

### 자바스크립트
#### 인터프리터 언어
- 인터프리터 언어란 번역(하이레벨 언어->기계어)과 실행을 순차적으로 동작시키는 언어를 인터프리터 언어라고 부름. 번역과 실행이 거의 동시에 실행되기에 1개의 액션이 존재하고 별도의 실행파일이 없음. 자바스크립트, 루비, 파이썬, PHP 등.
- 인터프리터 언어는 컴파일 언어에 비해 잦은 수정이 발생해도 매번 컴파일 할 필요가 없음. 그러나 번역과 실행을 하나의 액션에서 실행하므로 약간의 처리능력이 필요.
- 컴파일 언어란 실행 이전에 번역 작업을 하는 언어를 말함. 하이레벨 언어를 번역하고, 번역된 코드를 실행하는 2개의 액션이 존재. 컴파일을 하게 되면 실행가능한 프로그램이 생성됨. 이렇게 생성된 프로그램은 인터프리터를 이용해 실행시키는 것보다 빠름. 다만 소스코드가 클 경우 컴파일 시간이 오래 걸림. C, C++, JAVA 등
- 컴파일 언어의 장점은 컴파일한 운영체제의 사양에 최적화되어 실행되므로 속도가 빠르고 버그 발견이 용이. 그러나 실행환경(지정된 운영체제)에 최적화되게 만들어져있어 다른 운영체제에서 실행하기 위해선 재컴파일이 필요하고 코드의 일부가 바뀌어도 전체 코드를 재컴파일해야함.

#### 자바스크립트는 인터프리터 언어?
- 자바스크립트 엔진은 전통적인 인터프리터일 수도 있고, 특정한 방식으로 바이트코드로 JIT 컴파일을 할 수 있다.
- 보통은 인터프리터 언어라고 말하지만 자바스크립트도 컴파일 과정을 거친다. 크롬 V8 엔진의 경우 엔진이 실행할 JS 파일을 받은 후 파싱, AST(Abstract Syntax Tree)를 구축하고, 다음으로 인터프리터가 코드를 읽으며 실행한다. 코드를 수행하는 과정에서 프로파일러가 최적화할 수 있는 코드를 컴파일러에게 전달하면, 주로 반복해서 실행되는 코드 블록을 컴파일(최적화)함. 그 후 원래 있던 코드와 최적화된 코드를 바꿔줌. 
- 이런 식으로 코드를 우선 인터프리터 방식으로 실행하고 필요할 때 컴파일 하는 방법을 JIT(Just In Time) 컴파일러라고 부름. 즉, 자바스크립트는 실행되는 플랫폼에 따라 인터프리팅과 컴파일이 혼합되어 사용됨.

##### AST?
- 우리말로 옮기면 추상 구문 트리. 소스코드의 추상 구문 구조를 표현하기 위해 사용됨. 즉, 특정 프로그래밍 언어로 작성된 프로그램 소스 코드를 각각 의미별로 분리하여 컴퓨터가 이해할 수 있는 구조로 변경시킨 트리를 의미.

#### var, let, const의 차이
- var: 함수 스코프를 가지고 재선언해도 에러가 발생하지 않음.
- let: 블록(if, for, while 블록 등) 스코프를 가짐. 해당 블록을 벗어나면 사라짐
- const: 블록 스코프를 가지고 상수를 선언할 때 사용. 선언과 동시에 할당되며 재할당 불가능

#### 호이스팅(hoisting)
- 기본적으로 호이스트는 변수의 정의가 그 범위에 따라 선언/초기화/할당/분리되는 것을 의미
- 호이스팅은 함수 안에 있는 선언들을 모두 끌어올려서  해당 함수 유효 범위의 최상단에 선언하는 것을 말함. 필요한 값들을 위로 끌어올리는 것.

#### 클로저(closure)
- 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여 그 스코프 밖에서 호출되어도 해당 스코프에 접근할 수 있는 함수를 말함
- a라는 함수가 존재하던 스코프에 b라는 변수가 있을 때, 그 스코프 밖에서 a를 호출하면 a 함수가 b 변수에 접근할 수 있는 경우를 말함

#### call, bind, apply
- 위 세개 모두 함수 호출 방법에 이용된다. 보통 함수 호출은 함수 이름 뒤에 ()를 붙이거나 call, apply를 사용하여 호출하는 방법이 있다. call, apply는 각각 function.call(arguments), function,apply(arguments)처럼 사용된다.
##### call
- func.call(thisArg[, arg1[, arg2[, ...]]])
- call의 첫 매개변수에는 thisArg가 들어가는데, 이 thisArg라는 것은 각 함수의 실행문맥의 this를 특정하게 지정하는 매개변수를 의미한다. 그 뒤 부터는 호출할 함수에 필요한 변수들이 들어간다.
##### apply
- fun.apply(thisArg, [argsArray])
- thisArg는 call과 같고, argsArray는 call처럼 호출할 함수에 필요한 변수지만 apply의 경우에는 이 변수를 배열 형태로 넣게 된다.
##### bind
- func.bind(thisArg[, arg1[, arg2[, ...]]])
- thisArg는 call, apply와 같고 그 뒤의 인수는 call과 같다. 다만 bind의 경우 새롭게 함수를 만든다. bind는 call, apply처럼 함수가 가리키고 있는 this를 바꾸지만 호출은 하지 않는다. 그렇기에 따로 let arg = bindFunction ... bindFuntion() 처럼 변수를 할당하여 호출하는 형태로 사용된다.

#### 실행 문맥?
- 콜 스택과 유사한 역할을 수행한다. 다만 방식이 조금 다른데, 보통의 경우 함수를 호출할 때 필요한 정보는 콜 스택에 쌓이게 되며 그 정보는 매개변수, 종료 후 복귀 주소, 지역 변수 등을 말한다. 실행 문맥도 비슷하나 추가적으로 리스트 형태의 스코프 체인이라는 것을 저장하고 있다. 스코프 체인은 실행 문맥들이 연결된 리스트이며, 현재 실행 문맥에서 다른 문맥의 변수에 접근하도록 도와준다.
- 이후 다른 문맥의 식별자를 찾을 때 스코프 체인의 변수 객체를 순차적으로 방문하면서 찾고자하는 식별자가 존재하는지 확인한다.
- 가장 최초로 생성되는 문맥은 전역 실행 문맥이다. 그냥 js 파일을 만들었을 때의 문맥이라고 생각하면 편하고, 이후 정의된 함수가 실행될 때마다 문맥이 추가되며 스코프 체인도 해당 문맥과 결합된다.
