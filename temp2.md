## 디펜던시 인젝션
- 한글로 의존성 주입을 말함. 표준을 정의할 수 있고, 정의된 표준을 바탕으로 같은 설계를 하게 해줌.
- 객체가 의존하는 또 다른 객체를 외부에서 선언하고, 이를 주입받아 사용하는 것을 말함.

### 장점
1. 재사용성을 높여줌
2. 테스트에 용이
3. 코드 단순화
4. 종속적이던 코드의 수 줄어듦
5. 코드가 읽기 쉬워짐
6. 종속성 감소(코드 변경에 민감하지 않음)
7. 결합도는 낮추면서 유연성과 확장성 향상 가능
8. 객체간 의존관계 설정 가능
9. 객체간 의존관계를 없애거나 줄일 수 있음

## fetch와 axios의 차이
1. axios는 요청 객체에 url이 있지만 fetch는 없음
2. axios는 써드파티 라이브러리로 설치 필요. fetch는 필요 없음
3. axios는 XSRF 보호를 해줌. fetch는 없음
4. axios는 data 속성을 사용. fetch는 body 속성을 사용
5. data는 object를 포함. body는 문자열화
6. axios는 자동으로 json 형식으로 변환됨. fetch는 따로 .json()호출 필요
7. axios는 요청을 취소할 수 있고 타임아웃을 걸 수 있음. fetch는 불가능

#### XSRF?
- 사이트 간 요청 위조(CSRF라고도 부름)를 말하며, 웹 사이트 취약점 공격 방법 중 하나이다.
- 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격을 말한다.

## get과 post의 차이
- get은 클라이언트에서 서버로 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 메소드이다. 읽고, 검색하기 위해 사용된다.
- 또한 get은 요청을 전송할 때 url 주소로 파라미터가 포함되며, 이 부분을 쿼리 스트링이라고 부른다. 
- get 요청은 오직 데이터를 읽을 때만 사용되므로 데이터의 변형 위험없이 사용할 수 있는 메소드이다.
- post는 리소스를 생성하기 위해 서버에 데이터를 보내는 데 사용된다.
- post는 get과 달리 전송할 데이터를 HTTP 메시지의 body에 담아서 전송한다. body는 길이의 제한없이 데이터를 전송할 수 있기 때문에 get과 달리 대용량 데이터를 전송할 수 있다.
- post가 데이터를 HTTP 메시지의 body에 담아 get에 비해 직접 눈으로 보이진 않지만 확인할 방법은 있으므로 민감한 데이터는 암호화하여 전송해야 한다.
- get 요청은 캐시될 수 있지만 post는 안된다.
- get은 브라우저 기록에 남지만 post는 남지 않는다.
- 각각 성공 응답코드로 200, 201을 쓴다.
- get은 여러번 요청하더라도 동일한 응답이 돌아오지만, post는 응답이 다를 수 있다. 

## post와 put의 차이
- post는 create, put은 update에 매칭되며, 자원에 대한 생성은 post가, 자원에 대한 수정은 put이 담당한다.
- 다만 put을 쓸 때 기존에 없던 unique key로 특정 자원에 대한 put 요청을 보내면 그 자료는 생성된다. 
- 이것이 post와 다른 점은 post는 리소스를 생성하기 위한 메소드이므로 같은 자원(ex) 학생 정보)에 대한 생성 요청을 계속 보내면 그 리소스를 계속 생성한다(다만 unique key를 어떻게 설정하냐에 따라 생성되지 않을 수 있다). 
- 그러나 put의 경우 리소스의 수정에 대한 메소드이므로 만약 없는 unique key를 바탕으로 자원 수정을 요청하면 해당 자원을 생성하지만, 이후 같은 요청을 계속 보내면 리소스를 생성하지 않고 수정을 한다.
- 한마디로 post의 경우 매번 리소스를 생성하지만, put은 매번 같은 리소스를 반환한다.

### 그럼 patch와 put은?
- patch는 직접 써보진 않아서 모르겠지만 patch는 리소스의 일부분을 수정할 때 사용하고, put은 리소스의 모든 속성을 수정할 때 사용한다고 한다.

## cors란? 해결방법은?
- Cross-Origin Resource Sharing의 약자로, 도메인 또는 포트가 다른 서버의 자원을 요청하는 메커니즘을 말한다.
- 브라우저와 서버 간의 안전한 교차 출처 요청 및 데이터 전송을 지원한다. 
- 서로 다른 출처(Origin) 간에 리소스를 전달하는 방식을 제어하는 체제이다.
- 기본적으로 웹은 다른 출처의 리소스를 요청할 때 HTTP 프로토콜을 사용하여 요청 하는데, 이때 브라우저는 요청 헤더에 Origin 필드에 요청을 보내는 출처를 담아 전송한다.
- 서버는 요청에 대한 응답으로, 응답 헤더에 Access-Control-Allow-Origin이라는 값에 이 리소스를 접근하는 것이 허용된 출처를 준다. 이후 브라우저는 자신이 보낸 요청의 Origin과 서버가 준 Access-Control-Allow-Origin 의 값을 비교해본 후 유효한 응답인지 아닌지를 결정한다.

### 해결 방법
- Nest를 쓸 때는 app.use 같은 미들웨어 사용 방식에 enableCors라는, CORS 허용 옵션이 있었다. 나 같은 경우는 이 방법을 사용했고, 그냥 Express를 쓸 때는 cors 모듈을 설치하여 미들웨어 등록을 하는 것으로 해결했다.
- 원론적인 방법은 동일한 출처에서 리소스를 요청하게하면 된다(근데 모듈 등으로 지원해주는 방법이 있어 그냥 그 방법을 사용했다).

## 스레드와 프로세스란?
### 프로세스
- 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이다. 
- 프로그램은 파일이 저장 장치에 저장되어 있지만 메모리에 올라가 있지 않은 정적 상태를 말하는데, 이 프로그램이 메모리에 올라가 실행 상태가 된 것을 프로세스라고 한다.
- 운영체제 관점에서 프로세스가 최소 작업 단위가 된다(CPU 관점에서는 스레드).

### 스레드
- 스레드는 할당 받은 자원을 이용하는 실행의 단위이고, 프로세스 내에 여러개 생길 수 있다. 
- 프로세스와 다르게 스레드 간 메모리 공유가 가능하다. 스레드끼리 프로세스의 자원을 공유하면서 프로세스 실행 흐름의 일부가 된다.
- CPU 입장에서 최소 작업 단위가 된다.

## 프로세스와 스레드의 작동 방식
- 프로세스가 메모리 위에 올라갈 때 운영체제로부터 시스템의 자원을 할당받는데, 이때 운영체제는 프로세스마다 각각 독립된 메모리 영역을 코드, 데이터, 스택, 힙의 형식으로 할당해준다. 각각 독립된 영역을 주므로 프로세스는 다른 프로세스의 변수 등의 데이터에 접근할 수 없다(가능하긴 하지만 IPC라는 방법을 사용하는 등 번거로운 과정을 거친다고 한다).
- 스레드는 프로세스와 다르게 메모리를 서로 공유할 수 있는데, 이때 코드/데이터/스택/힙에서 스택 형식으로 할당된 메모리 영역은 따로 할당받지만, 나머지 코드/데이터/힙 영역은 서로 공유할 수 있다. 
- 즉, 각각의 스레드는 별도의 스택을 가지고, 힙 메모리는 서로 읽고 쓸 수 있다.
- 이렇게 프로세스 끼리는 메모리를 공유할 수 없고 스레드는 공유할 수 있으므로, 여기서 발생하는 차이점이 하나 있는데 프로세스는 하나의 프로세스가 장애로 종료되도 다른 프로세스는 영향을 받지 않지만 스레드는 메모리를 공유하므로 스레드 하나가 오류가 발생하면 다른 스레드들 모두가 종료된다.

## 멀티 프로세스(multi process)와 멀티 스레드(multi thread)
### 멀티 프로세스
- 멀티 프로세스는 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하는 것을 말한다.
- 하나의 프로세스가 잘못되어도 프로그램이 동작은 하지만, 컨텍스트 스위칭(context switching) 비용이 발생한다.
- 사실은 여러 개의 프로세스를 번갈아가며 실행하지만, 매우 빠른 속도이기에 동시에 실행되는 것처럼 보여 멀티 프로세스다.
- 이런 프로세스의 CPU 할당 순서 및 방법을 결정짓는 것을 스케쥴링이라고 한다.

### 멀티 스레드
- 프로그램을 여러 개의 스레드로 구성하고, 각 스레드가 작업을 처리하는 것을 말한다.
- 시스템 자원 소모가 감소하고, 처리 비용이 감소하며 실행 속도가 향상된다. 
- 컨텍스트 스위칭을 할 때 공유하고 있는 메모리만큼의 메모리 자원을 아낄 수 있다.
- 그러나 하나의 스레드 오류로 해당 프로세스에 오류가 발생할 수 있고, 디버깅이 어렵고, 스레드간 자원을 공유하기 때문에 동기화 이슈가 발생한다.

## Context Switching
- CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는데, 이 과정을 컨텍스트 스위칭이라고 한다.
- 컨텍스트 스위치 비용이란 동작중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고 대기하고 있다가, 다시 실행시 해당 상태를 복구하는 비용을 말한다.
- 보통 CPU 내에 존재하는 레지스터들은 현재 실행중인 프로세스 관련 데이터들로 채워지는데, 실행중인 프로세스가 변경되면 이런 레지스터의 값들이 변경되어야 한다. 이때 이전 프로세스가 지니고 있던 데이터들(PCB)을 나중에 이어서 실행하기 위해 저장해야 한다.

## PCB
- 프로세스를 컨트롤하기 위한 정보를 말한다.
- 프로세스 아이디(PID), 프로세스 상태, 다음에 실행할 명령어 주소, CPU 스케쥴링 정보, 프로세스의 주소 공간 등이 담겨있다. 이를 통틀어 Context라고 부른다.

### 프로세스의 상태변화
- 프로세스는 Ready, Running, Blocked 상태를 지닌다. 러닝 상태인 프로세스는 더 우선순위가 높은 프로세스가 실행되면 레디 상태가 되고, 우선순위가 높은 프로세스가 실행된다. 
- 블록 상태(or waiting)에 있는 프로세스는 러닝 상태에 있다가 프로그램이 입출력(I/O) 작업이나 특정 작업을 만나게 된 프로세스이다. 이후 입출력 작업 등이 종료되면 레디 상태가 된다. cpu를 다시 획득하면 러닝 상태가 된다.
- 물론 실행이 종료되면 terminated 상태가 된다.

### 컨텍스트 스위칭이 발생하는 경우
1. 입출력 요청(해당 프로세스가 블록 상태가 되며 다른 프로세스가 실행됨)
2. 해당 프로세스의 cpu 사용시간이 만료되었을 때
3. 자식 프로세스를 만들 때
4. 인터럽트 처리를 기다릴 때 
5. 기타 등등

## 스케쥴링 종류
- 비선점 스케쥴링: 어떤 프로세스가 cpu를 점유하고 있으면 해당 프로세스의 작업이 완료될 때 까지 다른 프로세스는 cpu를 사용할 수 없는 방법.
- 선점 스케쥴링: 어떤 프로세스가 cpu를 점유하고 있을 때 우선순위가 높은 다른 프로세스가 점유를 빼앗을 수 있는 방법.

## 스레드가 컨텍스트 스위칭에 미친 영향
- 스레드는 앞서 말했다시피 프로세스 내의 작업 단위로, 서로 자원 공유가 가능하다.
- 프로세스는 코드/데이터/스택/힙 메모리 영역을 가지는데, 프로세스가 교체되며 컨텍스트 스위칭이 일어날 때 마다 이 영역을 내리고, 실행할 프로세스의 코드/데이터/스택/힙 영역을 불러와야했다. 이런 비효율을 줄여보고자 스레드가 나타났다.
- 위와 같은 멀티 프로세스 방식을 개선하기 위해 나온 것이 멀티 스레드 방식이다. 멀티 프로세스 방식에서 각 프로세스들이 서로 메모리를 공유하지 못해 컨텍스트 스위칭 비용이 컸다면, 멀티 스레드 방식은 각 스레드의 실행 흐름을 위한 스택만 바꾸면 되었기에 코드/데이터/힙 영역은 스위칭이 일어나지 않아 비용이 낮았다.
- 그러나 스레드가 자원을 공유하기에 병목현상이나 데드락 등 동기화 문제가 발생할 수 있다.
- 내가 헷갈릴까봐 적어놓는 것인데, 멀티 프로세스와 멀티 스레드는 각자 다른 방식이다. 둘 다 작업을 더 효율적으로 하기 위해 나온 방법이지만 멀티 프로세스는 그 단위가 프로세스이고, 멀티 스레드는 그 단위가 스레드이다.
- 보통 브라우저의 각 탭 같은, 서로 독립된 작업인 경우 멀티 프로세스를 사용하고, 하나의 프로그램을 빠르게 실행할 경우 멀티 스레드를 사용한다고 한다.

## Thread safe?
- 여러 스레드가 동시에 사용되어도 안전하다는 것을 의미한다.
- 예를 들어 변수 X가 여러 스레드에서 호출되어도 하나의 스레드가 호출한 것과 같은 결과가 보장되어야 한다.


